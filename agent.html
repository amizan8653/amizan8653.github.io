<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Agent &mdash; Keepaway 7-1-2015 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '7-1-2015',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Keepaway 7-1-2015 documentation" href="index.html" />
    <link rel="next" title="ball" href="ball.html" />
    <link rel="prev" title="Welcome to keepaway’s documentation!" href="index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-agent">
<span id="agent"></span><h1>Agent<a class="headerlink" href="#module-agent" title="Permalink to this headline">¶</a></h1>
<p>This module contains the agent class.</p>
<dl class="class">
<dt id="agent.agent">
<em class="property">class </em><code class="descclassname">agent.</code><code class="descname">agent</code><span class="sig-paren">(</span><em>worldRef</em>, <em>simIndex</em>, <em>noisy_pos</em>, <em>sigma</em>, <em>agentType</em>, <em>noisyBallPos</em>, <em>maxPlayerSpeed</em>, <em>maxBallSpeed</em>, <em>inPossession=False</em><span class="sig-paren">)</span><a class="headerlink" href="#agent.agent" title="Permalink to this definition">¶</a></dt>
<dd><p>The agent Class</p>
<p>The agent class contains all the core functionality of the agent. All of the
intelligence or hand coded agents will go and inherit this class.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>worldRef</strong> (<a class="reference internal" href="keepAway.html#module-keepAway" title="keepAway"><em>keepAway</em></a>) &#8211; this is a reference to the simulator class. agent will
only be allowed to access the public methods in the simulator. It will
in no way be able to modify simulator values</li>
<li><strong>simIndex</strong> (<em>integer</em>) &#8211; The simulator that the agent keeps track of the agent in an array. 
The simIndex is the index position of this agent in the simulators array. This 
variable will help the simulator keep track of the agent</li>
<li><strong>noisy_pos</strong> (<em>tuple or list of floats</em>) &#8211; The agent shouldn&#8217;t know it&#8217;s exact position in the simulator, so
a noisy position is given to it. noisy_pos is a noisy reading of the agent&#8217;s 
position on the field.</li>
<li><strong>sigma</strong> (<em>float</em>) &#8211; this is the value that sets how noisy the agents readings of it&#8217;s position 
is, as well as the positions of the other players, as well as how accurate 
its perception of where the ball is.</li>
<li><strong>agentType</strong> (<em>string set to either &#8220;keeper&#8221; or &#8220;taker&#8221;</em>) &#8211; indicates if the is a keeper or a taker. Set agentType to &#8220;keeper&#8221; for 
keepers, and &#8220;taker&#8221; for takers.</li>
<li><strong>noisyBallPos</strong> (<em>tuple or list of floats</em>) &#8211; This is a noisy coordinate for the position of the ball on the 
field.</li>
<li><strong>maxPlayerSpeed</strong> (<em>integer</em>) &#8211; This indicates how fast the agent is allowed to move on the field.
This value is typically set to 2, for 2 pixels per time step.</li>
<li><strong>maxBallSpeed</strong> (<em>integer</em>) &#8211; This indicates how fast the ball is allowed to move on the field. 
This value is typically set to 3, for 3 pixels per time step. The value of maxBallSpeed 
should be higher than that of maxPlayerSpeed.</li>
<li><strong>inPossession</strong> (<em>boolean</em>) &#8211; This is an optional parameter that indicates if the player is currenly in
possession of the ball. Default value is false.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="agent.agent.__lt__">
<code class="descname">__lt__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#agent.agent.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>this function is simply used to allow comparision between different agents, so
that agents can be sorted. Agents are sorted based on which agent is closest to
the ball. So now, the simulator can call sorted(agents), and an array of all the 
agents is returned such that the agents are sorted based on who is closest to the ball.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">if self is closer to the ball than the other agent</td>
</tr>
<tr class="field-even field"><th class="field-name">RType:</th><td class="field-body">boolean</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="agent.agent.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#agent.agent.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="agent.agent._agent__blockPass">
<code class="descname">_agent__blockPass</code><span class="sig-paren">(</span><em>kIndex</em><span class="sig-paren">)</span><a class="headerlink" href="#agent.agent._agent__blockPass" title="Permalink to this definition">¶</a></dt>
<dd><p>This function will take a keeper to block as a parameter. The keeper 
that this taker is trying to block should NOT have the ball. 
This function works by taking the position of the keeper with the ball, 
and the position of the keeper to block, and making the taker run to the 
midpoint of these 2 positions. In 3V2 keepaway, this function should be 
implemented by the taker farther from the ball.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>kIndex</strong> (<em>integer</em>) &#8211; the index of the keeper to take, sorted by distance. so kIndex = 1 means
the keeper who is closest to the ball besides the keeper who has the ball. 
kIndex = 2 means the 2nd closest keeper, and so on.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">nothing</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="agent.agent._agent__getOpen">
<code class="descname">_agent__getOpen</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#agent.agent._agent__getOpen" title="Permalink to this definition">¶</a></dt>
<dd><p>This function implements a hand coded procedure to go and place individual agents
in an optimal position to receive a pass. The code for this function is 
based heavily on &#8220;Algorithm 2 GetOpen:Hand-coded&#8221;, which is the pseudo-code
for the getOpen function used by some other researchers and was published 
here:
http://www.cs.utexas.edu/users/pstone/Papers/bib2html-links/LNAI09-kalyanakrishnan-1.pdf</p>
<p>Only keeper who are not trying to go after the ball should call this method.
The decision for who goes after the ball or gets open is deterministic.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">nothing</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="agent.agent._agent__getRotatedVectors">
<code class="descname">_agent__getRotatedVectors</code><span class="sig-paren">(</span><em>vector</em>, <em>cos_k</em><span class="sig-paren">)</span><a class="headerlink" href="#agent.agent._agent__getRotatedVectors" title="Permalink to this definition">¶</a></dt>
<dd><p>FUNCTION NOT USED IN FINAL IMPLEMENTATION</p>
<p>This function will calculate 2 other angles that the agent can kick the ball to. If 
the agent has calculated a direct path from itself to another keeper, that should be
the input vector. If the agent is interested in passing at a 5 degree angle, then
the 2nd input should be the cosine of 5 degrees. This function will then calculate 
and return the 2 unit vectors which are the vectors pointing at 5 degree angles</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>vector</strong> (<em>list or tuple of numbers</em>) &#8211; the vector that points directly from the  ball&#8217;s noisy 
position to the noisy position of the keeper the agent wants to pass to</li>
<li><strong>cos_k</strong> (<em>number</em>) &#8211; the cosine of the angle that the agent wants to pass at. The
reason cosine is used instead of the angle is for computational efficiency</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">a list of 2 unit vectors, each one representing the 2 directions that
the ball can be kicked to achieve the desired angle.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list of tuples, each tuple being a tuple of floats.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="agent.agent._agent__goToBall">
<code class="descname">_agent__goToBall</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#agent.agent._agent__goToBall" title="Permalink to this definition">¶</a></dt>
<dd><p>If a keeper is calling this method, then this method will make the keeper
run directly towards the ball if the ball is stationary. If the ball is 
not stationary, then the simulator will use the calcReceieve methods in 
order to calculate the optimal intersection point that the keeper can 
run to. The keeper will then run towards that intercept point using 
this function. The only keeper that should be running to the ball is 
the keeper that can get to the ball the fastest. all other keepers should
be implementing the getOpen() function.</p>
<p>For a taker, the taker will simply run towards the ball. The taker that is 
closest to the ball should call this function, while the taker that is farther
should try to block a pass with blockPass method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">no return</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For keepers, this function will use information that is set when the simulator calls
the agent method receiveDecision. Do not call __goToBall for a keeper unless that
simulator function has been called.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="agent.agent._agent__initializeGetOpenGrid">
<code class="descname">_agent__initializeGetOpenGrid</code><span class="sig-paren">(</span><em>portionOfBorderToStayAwayFrom</em><span class="sig-paren">)</span><a class="headerlink" href="#agent.agent._agent__initializeGetOpenGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>the agent.__getOpen() needs to consider a very limited amount of points for 
computational efficiency. this function should be called during an agents
initialization. When called, this function will go and define the 
list of the 25 points that getOpen will check, arranged in a 5x5 grid</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>portionOfBorderToStayAwayFrom</strong> (<em>a float &gt; 0 but &lt; 1</em>) &#8211; When assigning points on the field
to check, the agent will not consider areas close to the border. For 
example, assume that 
portionOfBorderToStayAwayFrom = .15, and the height and width of the
field are both 100px. Then none of the 25 points will be in top 15 
rows of pixels, nor the bottom 15 rows of pixels. The same goes for 
the 15 leftmost columns of pixels, and the rightmost 15 columns of
pixels. The 5x5 grid of points to consider will be evenly spaced out
and laid in the 70 pixel by 70 pixel center.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a list containing the 25 coordinates of points to consider for
the agent.__getOpen() function</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">a list of coordinates. each coordinate is a tuple of floats</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="agent.agent._agent__receive">
<code class="descname">_agent__receive</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#agent.agent._agent__receive" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is implemented only by keepers. Each keeper will implement
this in order to decide if it should run towards the ball, or if it 
should try to get open to receive a pass.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">nothing</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="agent.agent._decisionFunction">
<code class="descname">_decisionFunction</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#agent.agent._decisionFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is meant to be over ridden by children class that are
inheriting this method. This method is responsible for intelligence 
decision of whether the ballkeeper should hold the ball, or pass
to one of it&#8217;s team mates.</p>
</dd></dl>

<dl class="method">
<dt id="agent.agent._holdBall">
<code class="descname">_holdBall</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#agent.agent._holdBall" title="Permalink to this definition">¶</a></dt>
<dd><p>If a keeper currently has the ball, then it has the option to hold the ball,
or pass it. Call this function to hold the ball. Holding the ball means the
agent holding the ball cannot move. Only the subclasses of agent should be
using this function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">no return</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="agent.agent._passBall">
<code class="descname">_passBall</code><span class="sig-paren">(</span><em>integerK</em><span class="sig-paren">)</span><a class="headerlink" href="#agent.agent._passBall" title="Permalink to this definition">¶</a></dt>
<dd><p>If a keeper currently has the ball, then it has the option to hold the ball,
or pass it. Call this function to pass the ball. integerK represents the 
keeper that the ball holder is passing to. integerK = 1 means pass to the 
keeper that is closest to the ball besides the ball holder. integerK = 2
means pass to the 2nd closest, and so on. Only subclasses of agent should
be calling this function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>integerK</strong> (<em>integer</em>) &#8211; this represents the 
keeper that the ball holder is passing to. integerK = 1 means pass to the 
keeper that is closest to the ball besides the ball holder. integerK = 2
means pass to the 2nd closest, and so on.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">no return</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="agent.agent.decisionFlowChart">
<code class="descname">decisionFlowChart</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#agent.agent.decisionFlowChart" title="Permalink to this definition">¶</a></dt>
<dd><p>This function will control the movement of keepers and takers. It controls 
movement by calling on all the private movement functions that are in defined
in this agent class</p>
</dd></dl>

<dl class="method">
<dt id="agent.agent.getAgentType">
<code class="descname">getAgentType</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#agent.agent.getAgentType" title="Permalink to this definition">¶</a></dt>
<dd><p>this function simply returns whether the agent is a keeper or taker</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">either &#8220;keeper&#8221; or &#8220;taker&#8221;</td>
</tr>
<tr class="field-even field"><th class="field-name">RType:</th><td class="field-body">string</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="agent.agent.getNoisyMidPoint">
<code class="descname">getNoisyMidPoint</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#agent.agent.getNoisyMidPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>this function simply returns the midpoint of this agent.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">noisy mid point</td>
</tr>
<tr class="field-even field"><th class="field-name">RType:</th><td class="field-body">tuple of integers</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="agent.agent.getSigma">
<code class="descname">getSigma</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#agent.agent.getSigma" title="Permalink to this definition">¶</a></dt>
<dd><p>this function simply returns the noise of the agent.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">noise value</td>
</tr>
<tr class="field-even field"><th class="field-name">RType:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="agent.agent.getSimIndex">
<code class="descname">getSimIndex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#agent.agent.getSimIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>this function simply returns index of the agent in the simulators 
corresponding array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">agent&#8217;s array index for the simuator&#8217;s array.</td>
</tr>
<tr class="field-even field"><th class="field-name">RType:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="agent.agent.get_noisy_pos">
<code class="descname">get_noisy_pos</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#agent.agent.get_noisy_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>this function simply returns the noisy position of the agent&#8217;s position on the field</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">noisy agent position</td>
</tr>
<tr class="field-even field"><th class="field-name">RType:</th><td class="field-body">tuple of floats</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="agent.agent.load_obj">
<code class="descname">load_obj</code><span class="sig-paren">(</span><em>name</em>, <em>index</em>, <em>inputAgent</em><span class="sig-paren">)</span><a class="headerlink" href="#agent.agent.load_obj" title="Permalink to this definition">¶</a></dt>
<dd><p>this function is for loading the saved training data. If the saved
training data exists, load it with pickle and return it. Otherwise,
return None.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>name</strong> (<em>string</em>) &#8211; the name you&#8217;re giving to the object you&#8217;re saving. 
So if you&#8217;re saving a dict object, you might wanna set 
the name to &#8220;training_dict&#8221;</li>
<li><strong>index</strong> (<em>integer</em>) &#8211; an integer representing the agent index in the simulators 
agent array. example: If saving a keeper 2&#8217;s dict, then index = 2.</li>
<li><strong>inputAgent</strong> (<em>string</em>) &#8211; name of type of agent. Such as &#8220;sarsa_agent&#8221;, 
or &#8220;neat_agent&#8221;</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">either the saved data, or None</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">RType:</th><td class="field-body"><p class="first last">object or None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="agent.agent.receiveBallReference">
<code class="descname">receiveBallReference</code><span class="sig-paren">(</span><em>inputBall</em><span class="sig-paren">)</span><a class="headerlink" href="#agent.agent.receiveBallReference" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gives the agent a reference to the field ball. Only
the keepaway.py module should be using this function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>inputBall</strong> (<a class="reference internal" href="ball.html#module-ball" title="ball"><em>ball</em></a>) &#8211; this is the ball that the agent is getting a
reference to. This function should only be called from the
simulator class.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">no return</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="agent.agent.receiveBirdsEyeView">
<code class="descname">receiveBirdsEyeView</code><span class="sig-paren">(</span><em>grid</em><span class="sig-paren">)</span><a class="headerlink" href="#agent.agent.receiveBirdsEyeView" title="Permalink to this definition">¶</a></dt>
<dd><p>The simulator will call this function in order to give the agent class
a the birds eye view of the field</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>grid</strong> (<em>2D arra of floats</em>) &#8211; a 2D grid of floats where each float represents a tile. Each tile will have a slightly
negative value for tiles that are in the path between Keeper 0 and a taker, and slightly positive
for tiles that are in the path from keeper 0 to the other keepers. Tiles that have a keeper on 
it have a value of 1, and tiles that have a taker on it have a value of -1.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">no return</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="agent.agent.receiveDecision">
<code class="descname">receiveDecision</code><span class="sig-paren">(</span><em>rDecision</em><span class="sig-paren">)</span><a class="headerlink" href="#agent.agent.receiveDecision" title="Permalink to this definition">¶</a></dt>
<dd><p>The simulator will call this function in order to give the agent class
a noisy version of the receive decision. The receive decision is just a 
tuple of 2 values: (argmin, point_to_run_to). the argmin is the index of
the keeper, indicating which keeper is in the best position to acquire the 
ball. The point_to_run_to is the point that this keeper must run to in order
to acquire the ball. More details about how the receieve decision is calculated
can be found in the calcReceive module.
Only the keepaway.py module should be calling this function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>rDecision</strong> (<em>tuple containing an integer and a 2D coordinate</em>) &#8211; a tuple containing the index of the keeper that&#8217;s in the 
best position to intercept the ball, and the coordinate that the keeper
needs to go and run to. The coordinates that are received from the 
simulator have some noise added to it.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">no return</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="agent.agent.receiveListOfOtherPlayers">
<code class="descname">receiveListOfOtherPlayers</code><span class="sig-paren">(</span><em>keeperArray</em>, <em>takerArray</em>, <em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#agent.agent.receiveListOfOtherPlayers" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gives the agent a reference to the simulators array
of keepers and takers. The index that is being input is value from
0 to 2, and indicates how relatively close the agent is to the ball.
Only the keepaway.py module should be calling this function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>keeperArray</strong> (<em>List or Tuple of agents</em>) &#8211; This is the array of keepers from the simulator</li>
<li><strong>takerArray</strong> (<em>List or Tuple of agents</em>) &#8211; This is the array of takers from the simulator</li>
<li><strong>index</strong> (<em>integer or float</em>) &#8211; the index is a value given to the agent indicating just
how close this agent is to the ball. For example, if an index of 0 is given, 
then that means this agent is the closest keeper/taker to the ball.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">no return</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="agent.agent.receiveSimpleStateVariables">
<code class="descname">receiveSimpleStateVariables</code><span class="sig-paren">(</span><em>noisyVariables</em><span class="sig-paren">)</span><a class="headerlink" href="#agent.agent.receiveSimpleStateVariables" title="Permalink to this definition">¶</a></dt>
<dd><p>The simulator will call this function in order to give the agent class
a noisy version of the simple state variables.
Only the keepaway.py module should be calling this function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>noisyVariables</strong> (<em>tuple or list of numbers</em>) &#8211; This is the array containing the noisy version
of the simple state variables.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">no return</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="agent.agent.save_obj">
<code class="descname">save_obj</code><span class="sig-paren">(</span><em>obj</em>, <em>name</em>, <em>index</em>, <em>inputAgent</em><span class="sig-paren">)</span><a class="headerlink" href="#agent.agent.save_obj" title="Permalink to this definition">¶</a></dt>
<dd><p>this function is for saving the training data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>obj</strong> (<em>any object</em>) &#8211; the actual object that you&#8217;re trying to save. It&#8217;s usually
a dict object that&#8217;s being saved.</li>
<li><strong>name</strong> (<em>string</em>) &#8211; the name you&#8217;re giving to the object you&#8217;re saving. 
So if you&#8217;re saving a dict object, you might wanna set 
the name to &#8220;training_dict&#8221;</li>
<li><strong>index</strong> (<em>integer</em>) &#8211; an integer representing the agent index in the simulators 
agent array. example: If saving a keeper 2&#8217;s dict, then index = 2.</li>
<li><strong>inputAgent</strong> (<em>string</em>) &#8211; name of type of agent. Such as &#8220;sarsa_agent&#8221;, 
or &#8220;neat_agent&#8221;</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">nothing</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="agent.agent.updateAgentPosition">
<code class="descname">updateAgentPosition</code><span class="sig-paren">(</span><em>noisyPosition</em><span class="sig-paren">)</span><a class="headerlink" href="#agent.agent.updateAgentPosition" title="Permalink to this definition">¶</a></dt>
<dd><p>The simulator will call this function in order to update the noisy position
of the agent. Noisy positions are used by the different agents for all
of the calculates that take place at the agent level. The simulator 
calculates things with the true positions, and the true positions are kept
private from the agent classes. 
Only the keepaway.py module should be calling this function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>noisyPosition</strong> (<em>tuple or list of numbers</em>) &#8211; This is a coordinate with a noisy reading of the
agent&#8217;s current position.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">no return</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Welcome to keepaway&#8217;s documentation!</a></li>
      <li>Next: <a href="ball.html" title="next chapter">ball</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/agent.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015, ali mizan.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.6</a>
      
      |
      <a href="_sources/agent.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>